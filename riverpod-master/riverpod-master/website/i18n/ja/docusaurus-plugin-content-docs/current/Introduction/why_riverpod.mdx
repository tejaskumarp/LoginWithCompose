---
title: なぜRiverpodなのか？
version: 2
---

import { AutoSnippet } from "/src/components/CodeSnippet";
import whyRiverpod from "/docs/introduction/why_riverpod";

## Riverpod とは？

Riverpod ([Provider](https://pub.dev/packages/provider)のアナグラム)は、
Flutter/Dart 用のリアクティブなキャッシングフレームワークです。

宣言的かつリアクティブなプログラミングを使用して、Riverpod はアプリケーションのロジックの多くを自動的に処理します。
ネットワークリクエストを実行し、エラーハンドリングやキャッシングを組み込み、必要に応じてデータを自動的に再取得します。

## モチベーション

現代のアプリケーションは、ユーザーインターフェースをレンダリングするために必要なすべての情報を最初から持っていることはほとんどありません。
代わりに、データはサーバーから非同期的に取得されることが一般的です。

問題は、非同期コードを扱うのが難しいことです。
Flutter には状態(state)変数を作成し、変更時に UI を更新する方法がありますが、依然として限界があります。
多くの課題が未解決のまま残っています:

- 非同期リクエストはローカルにキャッシュする必要があります。UI が更新されるたびにそれらを再実行するのは非現実的です。
- キャッシュがあると、そのキャッシュが古くなる可能性があります。
- エラーハンドリングやローディング状態も管理する必要があります。

これらの問題を大規模に解決するのは難しく、多くの機能に影響されます。例えば:

- pull to refresh
- 無限スクロール/スクロール時のデータ取得
- タイプしながらの検索
- 非同期リクエストのデバウンス
- 使用しなくなった非同期リクエストのキャンセル
- 楽観的 UI
- オフラインモード
- ...

これらの機能は実装が難しいですが、良いユーザー体験には不可欠です。
しかし、これらの問題に直接取り組むパッケージはほとんどなく、多くの作業は手動で行う必要があります。

そこで Riverpod の登場です。
Riverpod はこれらの問題を解決し、Flutter ウィジェットに触発された新しいビジネスロジックの書き方を提供します。
多くの点で、Riverpod はウィジェットに似ていますが、状態管理のためのものです。

この新しいアプローチを使用すると、これらの複雑な機能の大部分はデフォルトで処理されます。
残るのは UI に集中することだけです。

以下の例をご覧ください。
このスニペットは、Riverpod を使用して実装された [Pub.dev](https://github.com/rrousselGit/riverpod/tree/master/examples/pub) クライアントアプリケーションの簡略版です。

<AutoSnippet
  language="dart"
  {...whyRiverpod}
  translations={{
    fetchPackages: "// pub.devからパッケージのリストを取得します。",
    fetchApi:
      "  // APIを取得します。ここではpackage:dioを使用していますが、他のものを使用することもできます。",
    decodeJson: "  // JSONレスポンスをDartクラスにデコードします。",
  }}
/>

このスニペットは、"タイプしながらの検索"+"pull to refresh"+"無限リスト"のためのビジネスロジックをすべて含んでおり、エラー/ローディング状態も処理します。
